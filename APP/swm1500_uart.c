/****************************************************************************************************************************************** 
* 文件名称:	swm1500_uart.c
* 功能说明:	SWM1500单片机的UART串口功能驱动库
* 技术支持:	http://www.synwit.com.cn/e/tool/gbook/?bid=1
* 注意事项:
* 版本日期:	V1.0.0		2013年06月30日
* 升级记录: 
*
*
*******************************************************************************************************************************************
* @attention
*
* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION 
* REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, SYNWIT SHALL NOT BE HELD LIABLE 
* FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT 
* OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONN-
* -ECTION WITH THEIR PRODUCTS.
*
* COPYRIGHT 2012 Synwit Technology 
*******************************************************************************************************************************************/
// #include "SWM1500.h"
#include "swm1500_uart.h"


/****************************************************************************************************************************************** 
* 函数名称:	UART_Init()
* 功能说明:	UART串口初始化，包括数据位长度、停止位长度、校验位、波特率、FIFO触发深度、中断使能等的设置
* 输    入: UART_T * UARTx	指定要被设置的UART串口，有效值包括UART、UART2
*			UART_InitStructure * initStruct	包含UART串口相关设定值的结构体
* 输    出: 无
* 注意事项: 初始化串口之前，须先把该串口对应的引脚设置为正确的模式（数字外设模式）
******************************************************************************************************************************************/
void UART_Init(UART_T * UARTx,UART_InitStructure * initStruct)
{
	uint32_t tmp;

	UART_Open(UARTx);							//必须先给UART模块提供总线时钟，才能够对UART模块寄存器进行读写
	
	switch((uint32_t)UARTx)
	{
	case ((uint32_t)UART):
		UART->LCR.DLAB = 1;						//使能DLL、DLH寄存器访问
		UART->DLH = (SystemCoreClock/initStruct->baudrate/16)/256;
		UART->DLL = (SystemCoreClock/initStruct->baudrate/16)%256;
		UART->LCR.DLAB = 0;						//禁能DLL、DLH寄存器访问
		
		UART->LCR.DLEN = initStruct->data_len;
		UART->LCR.STOP = initStruct->stop_len;			
		UART->LCR.PEN  = initStruct->parity ? 1 : 0;
		UART->LCR.EPS  = (initStruct->parity == 2) ? 1 : 0;

		switch(initStruct->rxfifo)
		{
	   	case 1:
			tmp = 0;	break;
		case 4:
			tmp = 1;	break;
		case 8:
			tmp = 2;	break;
		case 14:
			tmp = 3;	break; 
		default:
			tmp = 1;	break;
		}
					
		UART->FCR = ((initStruct->rxfifo != 0) ? 1 : 0) | (3 << 1) | (tmp << 6);

		UART->u32IER = initStruct->RBR_IE | (initStruct->THR_IE << 1) | (initStruct->LSR_IE << 2);	
		if(initStruct->RBR_IE | initStruct->THR_IE | initStruct->LSR_IE)
		{
			NVIC_EnableIRQ(UART_IRQn);
		}
		break;
		
	case ((uint32_t)UART2):
		UART2->LCR.DLAB = 1;					//使能DLL、DLH寄存器访问
		UART2->DLH = (SystemCoreClock/initStruct->baudrate/16)/256;
		UART2->DLL = (SystemCoreClock/initStruct->baudrate/16)%256;
		UART2->LCR.DLAB = 0;					//禁能DLL、DLH寄存器访问
		
		UART2->LCR.DLEN = initStruct->data_len;
		UART2->LCR.STOP = initStruct->stop_len;			
		UART2->LCR.PEN  = initStruct->parity ? 1 : 0;
		UART2->LCR.EPS  = (initStruct->parity == 2) ? 1 : 0;

		switch(initStruct->rxfifo)
		{
	   	case 1:
			tmp = 0;	break;
		case 4:
			tmp = 1;	break;
		case 8:
			tmp = 2;	break;
		case 14:
			tmp = 3;	break; 
		default:
			tmp = 1;	break;
		}
					
		UART2->FCR = ((initStruct->rxfifo != 0) ? 1 : 0) | (3 << 1) | (tmp << 6);

		UART2->u32IER = initStruct->RBR_IE | (initStruct->THR_IE << 1) | (initStruct->LSR_IE << 2);	
		if(initStruct->RBR_IE | initStruct->THR_IE | initStruct->LSR_IE)
		{
			NVIC_EnableIRQ(UART2_IRQn);
		}
		break;
	}
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_Open()
* 功能说明:	UART串口使能，使能是指给UART模块提供工作时钟
* 输    入: UART_T * UARTx	指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_Open(UART_T * UARTx)
{
	switch((uint32_t)UARTx)
	{
	case ((uint32_t)UART):
		SYS->PCLK_EN.UART_CLK = 1;
		break;
	
	case ((uint32_t)UART2):
		SYS->PCLK_EN.UART2_CLK = 1;
		break;
	}	
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_Close()
* 功能说明:	UART串口禁能，禁能是指切断UART模块的时钟供给，从而减小能耗
* 输    入: UART_T * UARTx	指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_Close(UART_T * UARTx)
{
	switch((uint32_t)UARTx)
	{
	case ((uint32_t)UART):
		SYS->PCLK_EN.UART_CLK = 0;
		break;
	
	case ((uint32_t)UART2):
		SYS->PCLK_EN.UART2_CLK = 0;
		break;
	}
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_WriteByte()
* 功能说明:	发送一个字节数据
* 输    入: UART_T * UARTx	指定要被设置的UART串口，可取值包括UART、UART2
*			uint8_t byt		要发送的字节			
* 输    出: 无
* 注意事项: 函数调用之前需要检查并保证THR中没有数据
******************************************************************************************************************************************/
void UART_WriteByte(UART_T * UARTx,uint8_t byt)
{
	UARTx->THR = byt; 
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_ReadByte()
* 功能说明:	读取一个字节数据
* 输    入: UART_T * UARTx	指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 读取到的字节
* 注意事项: 函数调用之前需要检查并保证RBR中确实有可用数据 
******************************************************************************************************************************************/
uint8_t UART_ReadByte(UART_T * UARTx)
{
	return UARTx->RBR;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_WriteBytes()
* 功能说明:	发送len个字节数据
* 输    入: UART_T * UARTx	指定要被设置的UART串口，可取值包括UART、UART2
*			char buf[]		要发送的数据
*			uint32_t len	要发送的数据的个数
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_WriteBytes(UART_T * UARTx,char buf[],uint32_t len)
{
	uint32_t i;
	
	if(len > 8) 
		return;

	for(i=0;i<len;i++)
	{
		UARTx->THR = buf[i]; 
	}
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_ReadBytes()
* 功能说明:	读取len个字节数据
* 输    入: UART_T * UARTx	指定要被设置的UART串口，可取值包括UART、UART2
*			char buf[]		接收到的数据
*			uint32_t len	要接收的数据的个数
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_ReadBytes(UART_T * UARTx,char buf[],uint32_t len)
{
	uint32_t i;

	for(i=0;i<len;i++)
	{
		if(UARTx->LSR.DR == 1)
		{
			buf[i] = UARTx->RBR;	
		}
		else
		{
	   		break;
		}
	}

	return i;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_SetBaudrate()
* 功能说明:	设置波特率
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
*			uint32_t baudrate	要设置的波特率
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_SetBaudrate(UART_T * UARTx,uint32_t baudrate)
{
	UARTx->LCR.DLAB = 1;						//使能DLL、DLH寄存器访问
	UARTx->DLH = (SystemCoreClock/baudrate/16)/256;
	UARTx->DLL = (SystemCoreClock/baudrate/16)%256;
	UARTx->LCR.DLAB = 0;						//禁能DLL、DLH寄存器访问
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_GetBaudrate()
* 功能说明:	获取当前使用的波特率
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 当前使用的波特率
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_GetBaudrate(UART_T * UARTx)
{
	uint32_t baudrate;

	UARTx->LCR.DLAB = 1;						//使能DLL、DLH寄存器访问
	baudrate = SystemCoreClock/16/(UARTx->DLH*256+UARTx->DLL);
	UARTx->LCR.DLAB = 0;						//禁能DLL、DLH寄存器访问

	return baudrate;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_SetDataLen()
* 功能说明:	设置数据位长度
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
*			uint32_t data_len	要设置的数据位长度，可取值	0 5位		1 6位		2 7位		3 8位
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_SetDataLen(UART_T * UARTx,uint32_t data_len)
{
	UARTx->LCR.DLEN = data_len;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_GetDataLen()
* 功能说明:	获取当前的数据位长度
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 数据位长度	0 5位		1 6位		2 7位		3 8位
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_GetDataLen(UART_T * UARTx)
{
	return UARTx->LCR.DLEN;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_SetStopLen()
* 功能说明:	设置停止位长度
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
*			uint32_t stop_len	要设置的停止位长度，可取值 0 1位		1 2位
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_SetStopLen(UART_T * UARTx,uint32_t stop_len)
{
	UARTx->LCR.STOP = stop_len;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_GetStopLen()
* 功能说明:	获取当前的停止位长度
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 停止位长度 0 1位		1 2位
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_GetStopLen(UART_T * UARTx)
{
	return UARTx->LCR.STOP;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_SetParity()
* 功能说明:	设置校验位模式
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
*			uint32_t parity		要设置的校验位模式，可取值	0 无校验		1 奇校验		2 偶校验
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_SetParity(UART_T * UARTx,uint32_t parity)
{
	UARTx->LCR.PEN  = parity ? 1 : 0;
	UARTx->LCR.EPS  = (parity == 2) ? 1 : 0;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_GetParity()
* 功能说明:	获取当前校验位模式
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 校验位模式	0 无校验		1 奇校验		2 偶校验
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_GetParity(UART_T * UARTx)
{
	uint32_t parity;

	parity = (UARTx->LCR.PEN == 0) ? 0 : ((UARTx->LCR.EPS == 1) ? 2 : 1);

	return parity;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_SetRXFIFOTL()
* 功能说明:	设置RX FIFO Trigger Level（即RX FIFO接收到几个数据字节后触发RX FIFO满中断）
* 输    入: UART_T * UARTx	指定要被设置的UART串口，可取值包括UART、UART2
*			uint32_t level	要设置的RX FIFO触发等级，可取值	0 不使用FIFO	1 深度为1字节	4 深度为4字节	8 深度为8字节	14 深度为14字节
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_SetRXFIFOTL(UART_T * UARTx,uint32_t level)
{
	uint32_t tmp;

	switch(level)
	{
   	case 1:
		tmp = 0;	break;
	case 4:
		tmp = 1;	break;
	case 8:
		tmp = 2;	break;
	case 14:
		tmp = 3;	break; 
	default:
		tmp = 0;	break;
	}
				
	UARTx->FCR = ((level != 0) ? 1 : 0) | (3 << 1) | (tmp << 6);
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_GetRXFIFOTL()
* 功能说明:	获取串口当前的RX FIFO Trigger Level（即RX FIFO接收到几个数据字节后触发RX FIFO满中断）
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: RX FIFO触发等级	0 不使用FIFO	1 深度为1字节	4 深度为4字节	8 深度为8字节	14 深度为14字节
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_GetRXFIFOTL(UART_T * UARTx)
{
	uint32_t level;

	if((UARTx->FCR&0x01) == 0)
	{
		level = 0;

		return level;
	}

	switch(((UARTx->FCR >> 6) & 0x03))
	{
	case 0:
		level = 1;	break;
	case 1:
		level = 4;	break;
	case 2:
		level = 8;	break;
	case 3:
		level = 14;	break; 
	default:
		level = 0xFFFFFFFF;	break;
	}

	return level;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IntRBREn()
* 功能说明:	使能接收数据可用（即RBR中有数据）中断
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_IntRBREn(UART_T * UARTx)
{
	switch((uint32_t)UARTx)
	{
	case ((uint32_t)UART):
		UART->IER.RBR_IEN = 1;
		NVIC_EnableIRQ(UART_IRQn);
		break;
	
	case ((uint32_t)UART2):
		UART2->IER.RBR_IEN = 1;
		NVIC_EnableIRQ(UART2_IRQn);
		break;
	}
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IntRBRDis()
* 功能说明:	禁能接收数据可用（即RBR中有数据）中断
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_IntRBRDis(UART_T * UARTx)
{
	UARTx->IER.RBR_IEN = 0;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IntTHREn()
* 功能说明:	使能发送保持寄存器空中断
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_IntTHREn(UART_T * UARTx)
{
	switch((uint32_t)UARTx)
	{
	case ((uint32_t)UART):
		UART->IER.THR_IEN = 1;
		NVIC_EnableIRQ(UART_IRQn);
		break;
	
	case ((uint32_t)UART2):
		UART2->IER.THR_IEN = 1;
		NVIC_EnableIRQ(UART2_IRQn);
		break;
	}		
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IntTHRDis()
* 功能说明:	禁能发送保持寄存器空中断
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_IntTHRDis(UART_T * UARTx)
{
	UARTx->IER.THR_IEN = 0;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IntLSREn()
* 功能说明:	使能线状态（指帧错误、校验错误、溢出、Break 指示）中断
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_IntLSREn(UART_T * UARTx)
{
	switch((uint32_t)UARTx)
	{
	case ((uint32_t)UART):
		UART->IER.LSR_IEN = 1;
		NVIC_EnableIRQ(UART_IRQn);
		break;
	
	case ((uint32_t)UART2):
		UART2->IER.LSR_IEN = 1;
		NVIC_EnableIRQ(UART2_IRQn);
		break;
	}
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IntLSRDis()
* 功能说明:	禁能线状态（指帧错误、校验错误、溢出、Break 指示）中断
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 无
* 注意事项: 无
******************************************************************************************************************************************/
void UART_IntLSRDis(UART_T * UARTx)
{
	UARTx->IER.LSR_IEN = 0;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IntCurrent()
* 功能说明: 获取当前的中断状态，确定当前发生的是哪种中断
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 当前的中断状态		0 无中断	1 数据可用中断	2 发送保持寄存器空中断	3 线状态（指帧错误、校验错误、溢出、Break 指示）中断
*								4 字符超时中断
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_IntCurrent(UART_T * UARTx)
{
	uint32_t int_current;
		
	switch(UARTx->IIR.INT_ID)
	{
	case 1:	int_current = 0;	break;		//无中断

	case 2:	int_current = 2;	break;		//发送保持寄存器空中断

	case 4: int_current = 1;	break;		//数据可用中断

	case 6: int_current = 3;	break;		//线状态（指帧错误、校验错误、溢出、Break 指示）中断

	case 12:int_current = 4;	break;		//字符超时中断
		
	default:int_current = 0xFFFFFFFF;	break;
	}

	return int_current;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IsDataAvailable()
* 功能说明:	RBR中是否有有效字节
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 0 RBR中无有效字节		1 RBR中有有效字节
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_IsDataAvailable(UART_T * UARTx)
{
	return UARTx->LSR.DR;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IsRXOverflow()
* 功能说明:	RX是否发生溢出错误
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 0 RX无溢出错误		1 RX发生了溢出错误
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_IsRXOverflow(UART_T * UARTx)
{
	return UARTx->LSR.OE;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IsParityError()
* 功能说明:	是否发生了校验错误
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 0 未发生校验错误	1 发生了校验错误
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_IsParityError(UART_T * UARTx)
{
	return UARTx->LSR.PE;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IsFrameError()
* 功能说明:	是否发生了帧错误
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 0 未发生帧错误		1 发生了帧错误
* 注意事项: 无 
******************************************************************************************************************************************/
uint32_t UART_IsFrameError(UART_T * UARTx)
{
	return UARTx->LSR.FE;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_HasBreakIndicate()
* 功能说明:	是否发现Break Indicator
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 0 未发现Break Indicator		1 发现了Break Indicator
* 注意事项: 
******************************************************************************************************************************************/
uint32_t UART_HasBreakIndicate(UART_T * UARTx)
{
	return UARTx->LSR.BI;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IsTHREmpty()
* 功能说明:	THR（Transmit Hold Register，即发送保持寄存器）是否为空
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 0 THR不为空			1 THR为空
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_IsTHREmpty(UART_T * UARTx)
{
	return UARTx->LSR.THRE;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_IsTSREmpty()
* 功能说明:	TSR（Transmit Shift Register，即发送移位寄存器）是否为空
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 0 TSR不为空			1 TSR为空
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_IsTSREmpty(UART_T * UARTx)
{
	return UARTx->LSR.TEMT;
}

/****************************************************************************************************************************************** 
* 函数名称:	UART_RXFIFOError()
* 功能说明: RX FIFO中是否有错误（校验错误、帧错误、Break Indicator）
* 输    入: UART_T * UARTx		指定要被设置的UART串口，可取值包括UART、UART2
* 输    出: 0 RX FIFO中无错误	1 RX FIFO中有错误
* 注意事项: 无
******************************************************************************************************************************************/
uint32_t UART_RXFIFOError(UART_T * UARTx)
{
	return UARTx->LSR.RFE;
}
